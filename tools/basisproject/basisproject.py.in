#! /usr/bin/env python

# ============================================================================
# Copyright (c) 2011-2012 University of Pennsylvania
# Copyright (c) 2013-2016 Andreas Schuh
# All rights reserved.
#
# See COPYING file for license information or visit
# https://cmake-basis.github.io/download.html#license
# ============================================================================

##############################################################################
# @file  basisproject.py
# @brief Project tool used to create and/or modify a BASIS project.
#
# @ingroup Tools
##############################################################################

# ============================================================================
# modules
# ============================================================================

from __future__ import unicode_literals

import os                   # file manipulation
import sys                  # system functions
import re                   # regular expressions
import datetime             # now(), to get current year for copyright
import shutil               # copyfile()
import shlex                # lexical analysis, used for response files
import mimetypes            # to recognize configurable text files

from importlib.machinery import SourceFileLoader # i.e., template configuration

from basis import basis     # basic utilities
from basis import argparse  # command-line parsing
from basis import diff3     # three-way diff algorithm

from basis.utilities import binary_type, text_type

# ============================================================================
# constants
# ============================================================================

# constants used as values for the template options
DEL = -1 # remove feature/file if present
ADD =  1 # add feature/file if missing

# root directory of default project template
_template_dir = os.path.abspath(os.path.join(basis.exedir('basisproject'), '@TEMPLATE_DIR@'))
_template     = os.path.join(_template_dir, '@DEFAULT_TEMPLATE_NAME@/@DEFAULT_TEMPLATE_VERSION@')

# additional recognized MIME types of configurable text files
mimetypes.add_type('text/cmake',            '.cmake')
mimetypes.add_type('text/markdown',         '.md')
mimetypes.add_type('text/markdown',         '.mdown')
mimetypes.add_type('text/markdown',         '.markdown')
mimetypes.add_type('text/restructuredtext', '.rst')
mimetypes.add_type('text/doxygen',          '.dox')

# ============================================================================
# auxiliary functions
# ============================================================================
 
# ----------------------------------------------------------------------------
def read_rspargs(rspfile, argv):
    try:
        f = open(rspfile)
        for arg in f.readlines():
            argv = rspargs(shlex.split(arg, True), argv)
        f.close()
    except IOError as errmsg:
        sys.stderr.write(errmsg + '\n')
        sys.exit(1)
    return argv

# ----------------------------------------------------------------------------
def rspargs(args, argv):
    i = 0
    while i < len(args):
        if args[i] == '--responsefile':
            i += 1
            if i == len(args):
                sys.stderr.write("Option --responsefile requires an argument\n")
                sys.exit(1)
            argv = read_rspargs(args[i], argv)
        elif args[i][0] == '@':
            argv = read_rspargs(args[i][1:], argv)
        else:
            argv.append(args[i])
        i += 1
    return argv

# ----------------------------------------------------------------------------
def _update_deps(namespace, opts, deps, op):
    for dep in deps:
        namespace.ops[dep] = op
        if dep in opts and 'deps' in opts[dep]:
            _update_deps(namespace, opts, opts[dep]['deps'], op)

# ----------------------------------------------------------------------------
preset = None
def load_config(config_file, parser):
    # load template configuration
    config = SourceFileLoader('config', config_file).load_module()
    # set list of required files to [] if missing
    if not hasattr(config, 'required'):
        setattr(config, 'required', [])
    # add template options
    class OptAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            if not hasattr(namespace, 'ops'):
                setattr(namespace, 'ops', {})
            if option_string.startswith('--no'):
                op  = DEL
                opt = option_string[4:]
            else:
                op  = ADD
                opt = option_string[2:]
            namespace.ops[opt] = op
            if op == ADD: _update_deps(namespace, config.options, config.options[opt]['deps'], op)
    class MultiOptAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            if not hasattr(namespace, 'ops'):
                setattr(namespace, 'ops', {})
            if option_string.startswith('--no'):
                op  = DEL
                opt = option_string[4:]
            else:
                op  = ADD
                opt = option_string[2:]
            namespace.ops[opt] = op
            _update_deps(namespace, config.options, config.options[opt]['deps'], op)
    if hasattr(config, 'options'):
        if not type(config.options) is dict:
            sys.stderr.write('Invalid template configuration: ' + config_file + '\n')
            sys.stderr.write('The options attribute must be a dictionary.\n')
            sys.exit(1)
        for name in config.options:
            opt = config.options[name]
            if not 'desc' in opt: opt['desc'] = ''
            if not 'path' in opt: opt['path'] = []
            if not 'deps' in opt: opt['deps'] = []
            if not type(opt['path']) is list: opt['path'] = [opt['path']]
            if not type(opt['deps']) is list: opt['deps'] = [opt['deps']]
            if   len(opt['path']) > 0: action = OptAction
            elif len(opt['deps']) > 0: action = MultiOptAction
            else:
                sys.stderr.write('Invalid template configuration: ' + config_file + '\n')
                sys.stderr.write('Template option ' + name + ' has neither template paths nor dependencies.\n')
                sys.exit(1)
            parser.add_argument('--' + name, '--no' + name,
                    nargs=0, action=action, help=opt['desc'])
    else:
        setattr(config, 'options', {})
    # add preset options
    class PresetAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            if not hasattr(namespace, 'ops'):
                setattr(namespace, 'ops', {})
            name = option_string[2:]
            setattr(namespace, 'preset', name)
            for arg in config.presets[name]['args']:
                if arg.startswith('no'):
                    arg = arg[2:]
                    op  = DEL
                else:
                    op = ADD
                if arg in config.options:
                    namespace.ops[arg] = op
                    _update_deps(namespace, config.options, config.options[arg]['deps'], op)
    if hasattr(config, 'presets'):
        if not type(config.presets) is dict:
            sys.stderr.write('Invalid template configuration: ' + config_file + '\n')
            sys.stderr.write('The presets attribute must be a dictionary.\n')
            sys.exit(1)
    else:
        setattr(config, 'presets', {})
    if not 'full' in config.presets:
        config.presets['full'] = {
            'desc' : 'Choose project template with all optional files.',
            'args' : list(config.options.keys())
        }
    for name in config.presets:
        opt = config.presets[name]
        if not 'desc' in opt: opt['desc'] = ''
        if not 'args' in opt: opt['args'] = []
        if not type(opt['args']) is list: opt['args'] = [opt['args']]
        if len(opt['args']) > 0:
            for o in config.options:
                if not o in opt['args']:
                    opt['args'].insert(0, 'no' + o)
            parser.add_argument('--' + name, nargs=0, action=PresetAction, help=opt['desc'])
    # add options for subsitutions
    if not hasattr(config, 'substitutions'):
        setattr(config, 'substitutions', [])
    for key in config.substitutions:
        value = config.substitutions[key]
        if value == None:
            parser.add_argument('--' + key, metavar='<value>', default=None,
                help="Substitution value for <" + key + ">.")
        elif type(value) is dict:
            parser.add_argument('--' + key, metavar='<value>',
                default=value.get('default', None),
                help=value.get('help', "Substitution value for <" + key + ">."))
    return [config, parser]

# ----------------------------------------------------------------------------
def get_config_options(root, config, args, create):
    # use 'default' preset for project creation
    if create and not hasattr(args, 'preset'):
        if 'default' in config.presets and 'args' in config.presets['default']:
            for opt in config.presets['default']['args']:
                if opt.startswith('no'):
                    if not opt[2:] in args.ops:
                        args.ops[opt[2:]] = DEL
                else:
                    if not opt in args.ops:
                        args.ops[opt    ] = ADD
    # initialize operations such that existing project is unchanged
    # if modification not explicitly requested
    if hasattr(config, 'options'):
        for name in config.options:
            opt  = config.options[name]
            path = opt['path']
            for p in path:
                if not p == None and len(p) > 0:
                    path = p
                    break
            if name not in args.ops: args.ops[name] = None
            if args.ops[name] == None and path and os.path.exists(os.path.join(root, path)):
                args.ops[name] = ADD
    return args.ops

# ----------------------------------------------------------------------------
def get_project_name(cmake_file):
    """Extract project name from BasisProject.cmake file of existing project."""
    fp = open(cmake_file, 'rt')
    txt = fp.read()
    fp.close()
    m = re.search(r'\s*(basis_project|basis_slicer_module)\s*\((\s*#[^\n]*\n)*\s*(NAME|SUBPROJECT)\s+"?(?P<name>\w+)"?', txt)
    if m: return m.group('name')
    return None

# ----------------------------------------------------------------------------
def get_original_template(args):
    """Extract TEMPLATE from BasisProject.cmake file of existing project."""
    fp = open(os.path.join(args.root, 'BasisProject.cmake'), 'rt')
    txt = fp.read()
    fp.close()
    #m = re.search(r'\s+TEMPLATE\s+"(?P<template>[^"]*)"', txt)
    m = re.search(r'\s*(basis_project|basis_slicer_module)\s*\([^)]*TEMPLATE\s+"(?P<template>[^"]+)"', txt)
    if m: return os.path.join(_template_dir, m.group('template'))
    return None

# ----------------------------------------------------------------------------
def template_abspath(template):
    """Make absolute path from given template argument."""
    path = os.path.abspath(template)
    if not os.path.isdir(path):
        path = os.path.join(_template_dir, template)
    # if top-level template directory given, choose most recent version subdirectory
    if re.match(r'(.*)' + os.path.sep.replace('\\', '\\\\') + r'(\d+)\.(\d+)$', path) is None:
        try:
            versions = [subdir for subdir in os.listdir(path) if os.path.isdir(os.path.join(path, subdir))]
            versions.sort(key=lambda s: map(int, s.split('.'))) # fails if any subdir is not a version number
            path = os.path.join(path, versions[-1])
        except:
            pass
    return path

# ============================================================================
# add / remove project file
# ============================================================================

# ----------------------------------------------------------------------------
def get_template(template, path):
    m = re.match(r'(.*)' + os.path.sep.replace('\\', '\\\\') + r'(\d+)\.(\d+)$', template)
    if not m is None:
        root  = m.group(1)
        major = int(m.group(2))
        minor = int(m.group(3))
        # determine available template versions and stores minor version
        # numbers of each major version required to initialize minor number
        # when proceeding with the previous major version
        minors = {}
        for f in os.listdir(root):
            if os.path.isdir(os.path.join(root, f)):
                m = re.match('(\d+)\.(\d+)$', f)
                if not m is None:
                    k = int(m.group(1))
                    v = int(m.group(2))
                    if not k in minors: minors[k] = []
                    minors[k].append(v)
        # decrease template version until template file/directory exists
        while major > 0:
            while minor >= 0:
                template_path = os.path.join('%s/%d.%d' % (root, major, minor), path)
                if os.path.exists(template_path):
                    return template_path
                minor -= 1
            # set minor version number to maximum minor number for next major version
            while major > 0 and minor < 0:
                major -= 1
                if major in minors:
                    for next_minor in minors[major]:
                        if next_minor > minor: minor = next_minor
            if minor < 0: break
    # otherwise, just return input
    return os.path.join(template, path)

# ----------------------------------------------------------------------------
def add_dependencies(txt, deps, required=True, test=False):
    """Add dependencies to basis_project() command in BasisProject.cmake file."""
    if test:
        if required:
            placeholder = '#<test-dependency>'
        else:
            placeholder = '#<optional-test-dependency>'
    else:
        if required:
            placeholder = '#<dependency>'
        else:
            placeholder = '#<optional-dependency>'
    for dep in deps:
        txt = txt.replace(placeholder, dep + '\n    ' + placeholder, 1)
    return txt

# ----------------------------------------------------------------------------
def alter(filename, args, backup=True, update=False):
    """Alter project file, i.e., substitute placeholders.

    @param [in] filename Path of text file to alter.
    @param [in] args     Command-line arguments.
    @param [in] backup   Whether to backup file before overwriting it.
    @param [in] update   Whether template file is generated for the update
                         of an existing project file. In this case, certain
                         modifications should not be applied to avoid conflicts.

    @retval -1 on error
    @retval  0 if file was not modified
    @retval  1 if file has been modified

    @todo What can be done about removing files which have been automatically
          modified during project creation ? It would be best if this does not
          result in a conflict and thus skipping of the deletion if nothing else
          of the file content has changed. The @p update argument is currently
          more or less useless again after the template configuration has been
          introduced and not only fixed substitutions are performed.
    """
    if  hasattr(args, 'noalter') and args.noalter: return 0
    # ensure that file is a text file that can be configured
    if not filename.endswith('.in'):
        mtype = mimetypes.guess_type(filename)[0]
        if not (mtype and mtype.startswith('text/')): return 0
    # read file content
    fp = open(filename, 'rt')
    txt = fp.read()
    fp.close()
    out = txt
    # <author>
    if hasattr(args, 'author') and args.author:
        start = out.find('<author>')
        if start != -1:
            linestart = out.rfind('\n', 0, start)
            if linestart == -1: linestart  = 0
            else:               linestart += 1
            authors = [a.strip() for a in args.author.split(',')]
            prefix  = out[linestart:start].replace("AUTHORS", "       ").replace("AUTHOR", "      ")
            if len(prefix) > 0 and prefix[-1] == '#':
                for author in authors:
                    out = out.replace('#<author>', ''.join(['"', author, '"\n', prefix, '<author>']), 1)
            else:
                authors = ('\n' + prefix).join(authors)
                out = out.replace('<author>', authors)
    # dependencies
    if filename.endswith('BasisProject.cmake'):
        if hasattr(args, 'use') and args.use:
            out = add_dependencies(out, args.use, required=True, test=False)
        if hasattr(args, 'useopt') and args.useopt:
            out = add_dependencies(out, args.useopt, required=False, test=False)
        if hasattr(args, 'usetest') and args.usetest:
            out = add_dependencies(out, args.usetest, required=True, test=True)
        if hasattr(args, 'useopttest') and args.useopttest:
            out = add_dependencies(out, args.useopttest, required=False, test=True)
    # iterate over remaining substitutions until nothing else changes to allow
    # recursion but with a fixed maximum recursive depth to avoid endless recursion
    for iter in range(0, 3):
        last = out
        # <template>
        if not update:
            template = args.template
            if args.template.startswith(_template_dir):
                m = re.search(r'/(?P<name>[^/]+)/(?P<version>[0-9]+\.[0-9]+)$', args.template)
                if m: template = m.group('name') + '/' + m.group('version')
            out = out.replace('#<template>', '"' + template + '"')
            out = out.replace( '<template>',       template)
        # <project> or <project_l>
        if hasattr(args, 'name') and args.name:
            out = out.replace('#<project>',   '"' + args.name + '"')
            out = out.replace( '<project>',         args.name)
            out = out.replace('#<project_l>', '"' + args.name.lower() + '"')
            out = out.replace( '<project_l>',       args.name.lower())
        # <description>
        if hasattr(args, 'description') and args.description:
            out = out.replace('#<description>', '"' + args.description.replace('"', '\\"') + '"')
            out = out.replace( '<description>',       args.description.replace('"', '\\"'))
        # substitutions defined by template configuration
        for key in config.substitutions:
            value = config.substitutions[key]
            arg   = key.replace('-', '_')
            if value == None:
                if hasattr(args, arg):
                    value = getattr(args, arg, None)
            elif type(value) is dict:
                if hasattr(args, arg):
                    value = getattr(args, arg, None)
                elif 'default' in value:
                    value = value['default']
                else:
                    value = None
            if not value == None:
                if type(value) is binary_type:
                    value = text_type(value)
                if type(value) is text_type:
                    value = value.replace('"', '\\"')
                else:
                    value = text_type(value)
                out = out.replace('#<' + key + '>', '"' + value + '"')
                out = out.replace( '<' + key + '>',       value)
        # break if content no more changed
        if out == last: break
    # return if file content is unchanged
    if out == txt: return 0
    # otherwise, backup file first
    if backup:
        try:
            shutil.copy(filename, filename + '~')
        except Exception as e:
            sys.stderr.write("E %s - failed to backup file before altering it" % filename)
            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
            sys.stderr.write('\n')
            return -1
    # then overwrite it
    fp = open(filename, 'wt')
    fp.write(out)
    fp.close()
    return 1

# ----------------------------------------------------------------------------
def update_project_template(args):
    """Update TEMPLATE argument in BasisProject.cmake file."""
    ok = True
    filename = os.path.join(args.root, 'BasisProject.cmake')
    fp = open(filename, 'rt')
    if fp:
        txt = fp.read()
        fp.close()
        template = args.template
        if args.template.startswith(_template_dir):
            m = re.search(r'/(?P<name>[^/]+)/(?P<version>[0-9]+\.[0-9]+)$', args.template)
            if m: template = m.group('name') + '/' + m.group('version')
        if re.search(r'\s+TEMPLATE\s+"' + template + '"', txt):
            return 0
        else:
            out = re.sub(r'(\s+)TEMPLATE(\s+)"[^"]*"', '\\1TEMPLATE\\2"' + template + '"', txt)
    else:
        ok = False
    if ok and out != txt:
        fp = open(filename, 'wt')
        if fp:
            fp.write(out)
            fp.close()
        else:
            ok = False
    else:
        ok = False
    if ok:
        sys.stderr.write("G %s\n" % filename)
        return 1
    else:
        sys.stderr.write("E %s - failed to update TEMPLATE argument\n" % filename)
        return -1

# ----------------------------------------------------------------------------
def add(path, args, isdir=False):
    """Add or modify project directory or file.

    @param [in] path  The path of the directory or file relative to the
                      template or project root, respectively.
    @param [in] args  Namespace with command-line arguments.
    @param [in] isdir Whether @p path is a directory that may not have
                      a corresponding template.

    @retval -1 on error
    @retval  0 if existing file is up to date
    @retval  1 if project file has been added/updated
    @retval  2 if project file has been updated, but with conflicts

    """
    retval = 0

    template_path          = get_template(args.template,          path)
    original_template_path = get_template(args.original_template, path)
    project_path           = os.path.join(args.root,              path)

    # check existence of template
    if not isdir and not os.path.exists(template_path):
        sys.stderr.write("E %s - template missing\n" % project_path)
        return -1

    # handle case that path in project exists already
    if os.path.exists(project_path):
        if isdir or os.path.isdir(template_path):
            if not os.path.isdir(project_path):
                # template is directory, but there is a file in the project
                sys.stderr.write("E %s - not a directory\n" % project_path)
                return -1
            else:
                # directory already exists, nothing to do
                return 0
        elif os.path.isfile(template_path):
            if not os.path.isfile(project_path):
                # template is file, but there is a directory in the project
                sys.stderr.write("E %s - not a file\n" % project_path)
                return -1
            # if update of existing files is disabled, only alter file
            # to add further dependencies or specify an author...
            if not args.upgrade:
                rv = alter(project_path, args, backup=args.backup)
                if rv == 1: print("M %s" % project_path)
                return rv

    # create (intermediate) directory
    if isdir or os.path.isdir(template_path):
        path_dir = path
    else:
        path_dir = os.path.dirname(path)
    project_dir = os.path.join(args.root, path_dir)
    if not os.path.isdir(project_dir):
        try:
            os.makedirs(project_dir)
            print("A %s" % project_dir)
        except Exception as e:
            sys.stderr.write("E %s - failed to make directory" % project_dir)
            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
            sys.stderr.write('\n')
            return -1

    # add/update file
    if os.path.isfile(template_path):
        # project file does not exist yet
        if not os.path.isfile(project_path):
            # copy template
            try:
                shutil.copyfile(template_path, project_path)
            except Exception as e:
                sys.stderr.write("E %s - failed to add file" % project_path)
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                return -1
            # alter project file, e.g., substitute for project name
            try:
                if alter(project_path, args, backup=False) == -1:
                    retval = -1
            except Exception as e:
                retval = -1
            if retval != -1:
                print("A %s" % project_path)
                retval = 1
            else:
                sys.stderr.write("E %s - failed to alter file, may require manual edits" % project_path)
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
        # project file exists already
        else:
            # update project file if copy of previous template exists
            if os.path.isfile(original_template_path):
                # alter new template
                try:
                    shutil.copyfile(template_path, project_path + '.template')
                    if alter(project_path + '.template', args, backup=False, update=True) == -1:
                        raise Exception('failed to alter template file')
                except Exception as e:
                    sys.stderr.write("E %s - failed to create temporary template" % project_path)
                    if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                    sys.stderr.write('\n')
                    return -1
                # merge new template with project file using three-way diff
                fp = open(project_path, 'rt')
                current = fp.readlines()
                fp.close()
                fp = open(project_path + '.template', 'rt')
                template = fp.readlines()
                fp.close()
                fp = open(original_template_path, 'rt')
                initial = fp.readlines()
                fp.close()
                merge = diff3.merge(current, initial, template)
                # check if anything has changed at all
                if merge['body'] != current:
                    # in case of conflicts, backup file using .mine suffix
                    if merge['conflict']:
                        try:
                            shutil.copy(project_path, project_path + '.mine')
                        except Exception as e:
                            sys.stderr.write("E %s - failed to backup file" % project_path)
                            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                            sys.stderr.write('\n')
                            return -1
                    # otherwise, backup current project file using ~ suffix
                    elif args.backup:
                        try:
                            shutil.copyfile(project_path, project_path + '~')
                        except Exception as e:
                            sys.stderr.write("E %s - failed to backup file" % project_path)
                            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                            sys.stderr.write('\n')
                            return -1
                    # replace project file by merged file
                    try:
                        fp = open(project_path, 'wt')
                        fp.writelines(merge['body'])
                        fp.close()
                    except Exception as e:
                        sys.stderr.write("E %s - failed to update file" % project_path)
                        if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                        sys.stderr.write('\n')
                        return -1
                    if retval != -1:
                        if merge['conflict']: retval = 2
                        else:                 retval = 1
                # remove altered template again if update was successful
                if not merge['conflict']:
                    try:
                        os.remove(project_path + '.template')
                    except Exception as e:
                        sys.stderr.write("E %s - failed to remove temporary file" % project_path)
                        if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                        sys.stderr.write('\n')
                        retval = -1
            # cannot update files without copy of original template
            # note that this may also be caused by a project file of
            # same name as a newly added template file
            else:
                try:
                    # copy current template for reference next to the corresponding project file
                    shutil.copyfile(template_path, project_path + '.template')
                except:
                    pass
                sys.stderr.write("S %s - cannot add or update file: either project file of same name exists already or missing original template\n" % project_path)
                retval = -1
            # print status message if file was updated
            if retval > 0:
                if merge['conflict']: print("C %s" % project_path)
                else:                 print("G %s" % project_path)
    # done
    return retval

# ----------------------------------------------------------------------------
def remove_directory(path):
    isempty = True
    for filename in os.listdir(path):
        if filename != '.svn':
            isempty = False
            break
    if isempty:
        shutil.rmtree(path)
        return True
    return False

# ----------------------------------------------------------------------------
def delete(path, args, isdir=False):
    """Delete file or empty directory.

    @param [in] path  Path relative to template or project root, respectively.
    @param [in] args  Namespace with command-line arguments.
    @param [in] isdir Whether @p path is a directory path that may not have
                      a corresponding template.

    @retval -1 on error
    @retval  0 if file/directory did not exist
    @retval  1 if file/directory was removed

    """
    retval = 0

    original_template_path = get_template(args.original_template, path)
    project_path           = os.path.join(args.root,              path)

    # delete existing directory
    if os.path.isdir(project_path):
        if args.force:
            try:
                shutil.rmtree(project_path)
            except Exception as e:
                sys.stderr.write("E %s - failed to remove directory" % project_path)
                if verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                retval = -1
        else:
            try:
                os.rmdir(project_path)
            except Exception as e:
                sys.stderr.write("E %s - failed to remove directory;"
                                 " use --force to force deletion of non-empty directory" % project_path)
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                retval = -1
        if retval != -1:
            print("D %s" % project_path)
            retval = 1
    # delete existing file
    elif os.path.isfile(project_path):
        # check if project file differs from template
        if not args.force:
            if not os.path.isfile(original_template_path):
                sys.stderr.write("E %s - original template missing, use --force to force deletion\n" % project_path)
                return -1
            # alter new template
            try:
                shutil.copyfile(original_template_path, project_path + '.template')
                if alter(project_path + '.template', args, backup=False) == -1:
                    raise Exception('failed to alter template file')
            except Exception as e:
                sys.stderr.write("E %s - failed to create temporary template,"
                                 " use --force to force deletion")
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                return -1
            # compare files
            fp = open(project_path, 'rt')
            current = fp.read()
            fp.close()
            fp = open(project_path + '.template', 'rt')
            template = fp.read()
            fp.close()
            # remove altered template file
            try:
                os.remove(project_path + '.template')
            except Exception as e:
                sys.stderr.write("E %s - failed to remove temporary file" % project_path)
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                retval = -1
            # check for differences
            if current != template:
                if retval != -1:
                    sys.stderr.write("S %s - file was modified, use --force to force deletion\n" % project_path)
                return -1
        # delete project file
        try:
            os.remove(project_path)
        except Exception as e:
            sys.stderr.write("E %s - failed to remove file" % project_path)
            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
            sys.stderr.write('\n')
            return -1
        # print status message
        if retval != -1:
            print("D %s" % project_path)
            retval = 1
        # remove now empty directories
        subdir = os.path.dirname(project_path)
        while subdir != args.root:
            try:
                if remove_directory(subdir):
                    print("D %s" % subdir)
            except Exception as e:
                sys.stderr.write("W %s - failed to remove directory" % subdir)
                if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                sys.stderr.write('\n')
                retval = -1
                break
            subdir = os.path.dirname(subdir)
    # done
    return retval

# ----------------------------------------------------------------------------
def addordel(op, path, args):
    """Add/update or delete file or directory depending on operation specified.

    @param [in] op    Operations. Either one of ADD, None, or DEL.
    @param [in] path  File path relative to template or project root, respectively.
    @param [in] args  Namespace with command-line arguments.

    @retval -1 on error
    @retval  0 if nothing was done
    @retval  1 if operation was successful

    """
    # determine if path is file or directory
    if path.endswith('/'):
        isdir = True
        path  = path[:-1]
    else:
        isdir = False
    # add file/directory to project
    if op == ADD:
        return add(path, args, isdir=isdir)
    # delete file/directory from project
    elif op == DEL:
        return delete(path, args, isdir=isdir)
    # nothing to do otherwise
    return 0

# ----------------------------------------------------------------------------
class AccumulatorForNumbersOfChangesAndErrors(object):
    """Helper class used to accumulate number of changes, conflicts, and
       errors when calling either one of the add(), delete(), or addordel()
       functions."""
    # ------------------------------------------------------------------------
    changes   = 0
    conflicts = 0
    errors    = 0
    # ------------------------------------------------------------------------
    def call(self, func, *args, **kwargs):
        """Call the specified function with the given arguments."""
        rt = func(*args, **kwargs)
        if rt == -1: self.errors += 1
        else:
            if rt  > 0: self.changes   += 1
            if rt == 2: self.conflicts += 1
        sys.stdout.flush()

# ============================================================================
# main
# ============================================================================

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    ok = True
    
    # ------------------------------------------------------------------------
    # program help
    parser = argparse.ArgumentParser(prog='basisproject', description="""
  This tool can create a new project from a template or modify an existing project.\n\n
  
  Creating a new project:

    Example for creating a new project which contains the full functionality
    provided by the configured default project template:

      basisproject create --name        ProjectName
                          --description "Brief description of what it does."
                          --author      "Author Name1, Author Name2"
                          --full

    You can also select the components of a template you want in your project,
    or update an existing project with additional template files and directories.

    Note: Most projects do not need the full functionality. It is recommended to
          start with the --default set of files and add others when needed.

  Updating a project:
 
    Functionality can be removed by updating a project with the --no* options.
    However, directories and files are only deleted if they are empty or were
    not modified, respectively, by the project developer since their creation.
    The deletion of modified files can be forced by supplying the --force option.

  External package requirements:

    Besides the name of the new project and a brief description, names of external
    packages required or optionally used by this project can be specified. For each
    such package, an entry in the list of dependencies given as argument to either
    one of the DEPENDS* options of the basis_project() command is added. The call
    to this command can be found in the BasisProject.cmake file of the project.

  Upgrading a project:

    The basisproject tool can upgrade an existing project to a newer template version, 
    given that the existing directory structure and file names were preserved.
  
    User changes to previously added template files are kept and merged with the
    changes of the project template using a so-called three-way diff. This update
    process is similar to how remote changes are merged with your working copy changes
    by version control systems such as Subversion or Git.
  
    If the automatic file merge is not successful, basisproject creates:
  
        - a copy of the original project file (*.mine)
        - the new template file (*.template) 
        - the project file which has been overwritten with the merged content
          including markers to indicate where the conflicts occurred.

    The project file has to be edited manually or with a merge tool such as kdiff3 to 
    resolve any conflicts. Once the conflicts have been resolved, the *.mine and 
    *.template files must be removed either with the --cleanup option or manually 
    before another update is possible.""",
        formatter_class=argparse.RawTextHelpFormatter,
        argument_default=None,
        add_help=False)

    # ----------------------------------------------------------------------------
    # read arguments from response file first
    parser.add_argument('--responsefile', metavar='<file>', type=os.path.abspath,
            help="""File containing additional command line parameters to parse
before execution. Include other response files recursively using @/path/to/file.rsp""")

    args, argv = parser.parse_known_args(sys.argv[1:])
    if args.responsefile: argv = read_rspargs(args.responsefile, argv)

    # ----------------------------------------------------------------------------
    # define command-line arguments

    # --version
    parser.add_argument('--version', action='version',
            help="Show version information and exit.",
            version="""%(prog)s (@PROJECT_NAME@) @PROJECT_VERSION_AND_REVISION@
Copyright (c) 2011-2012 University of Pennsylvania, 2013-2014 Andreas Schuh. All rights reserved.
See https://cmake-basis.github.io/download.html#software-license.""")

    # --verbose
    parser.add_argument('-v', '--verbose', action='count', default=0,
            help="Increase verbosity of output messages.")

    # --template
    parser.add_argument('--template', metavar='<dir>', default=_template,
            help="""Root directory of project template. Paths can be absolute or relative to
either the current working directory or the installation directory of the
default templates. The configured default template is used if none specified.""")
    
    # --templates-dir
    class PrintTemplatesDir(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print(_template_dir)
            sys.exit(0)

    parser.add_argument('--templates-dir', nargs=0, default=argparse.SUPPRESS, action=PrintTemplatesDir,
            help="""Print default templates directory and exit.""")

    # --help
    parser.add_argument('-h', '--help', default=argparse.SUPPRESS, action='help',
            help="""Print help and exit. For help with subcommand arguments type 'basisproject help <command>'.""")

    # --helpall
    parser.add_argument('--helpall', default=argparse.SUPPRESS, action='store_true',
            help="""Print the complete help for all commands.""")

    # ----------------------------------------------------------------------------
    # parse common options
    if len(argv) > 0:
        args, argv_remaining = parser.parse_known_args(argv)
        args.template = template_abspath(args.template)
    else:
        args.template = _template
    
    template_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,add_help=False)
    custom_template_group = template_parser.add_argument_group("optional arguments imported from template\n'" + args.template + "'")

    # ----------------------------------------------------------------------------
    # load template configuration
    config_file = get_template(args.template, '_config.py')
    if not os.path.isfile(config_file):
        sys.stderr.write('Unknown template or missing template configuration file:\n' + config_file + '\n')
        sys.stderr.write('\nPlease specify a valid project template directory using --template.\n')
        sys.exit(1)
    config, custom_template_group = load_config(config_file, custom_template_group)
    
    subparsers = parser.add_subparsers(help='Command specifying the type of modification to make.', dest='subparser_name')
    
    # ----------------------------------------------------------------------------
    # the shared_parser is for commands that work across all subparsers
    shared_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,add_help=False)

    # --root
    shared_parser.add_argument('--root', metavar='<dir>', type=os.path.abspath, default=None,
            help="""Project root directory. Defaults to a subdirectory named after the
project created in the current working directory. In order to update
an existing project, specify the root directory of this project
using this option.""")

    # --cleanup
    shared_parser.add_argument('--cleanup', action='store_true', default=False,
            help="""Remove files resulting from merge conflicts of a previous update
of existing project files and backups. The conflicts should have
been manually resolved before using this option.""")

    # --nobackup
    shared_parser.add_argument('--nobackup', action='store_false', default=True, dest='backup',
            help="""Disable backup of existing project files. By default, whenever an
existing project file is modified, a backup of this file is made and saved under the
same filename, but with the ~ character as suffix. If this option is given, such backup
files are not made. In case of a merge conflict, however, existing project files are
always backed-up, using .mine as suffix for the file name of the backup in this case.""")

    # ----------------------------------------------------------------------------
    # parser for specified dependencies -- used by create and update subcommand
    depends_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, add_help=False)

    depends_parser.add_argument('--use', metavar='<pkg>', action='append', default=[],
            help="""Name of external package used by this project (case sensitive).""")
    depends_parser.add_argument('--useopt', metavar='<pkg>', action='append', default=[],
            help="""Name of external package optionally used by this project (case sensitive).""")
    depends_parser.add_argument('--usetest', metavar='<pkg>', action='append', default=[],
            help="""Name of external package required by tests of this project (case sensitive).""")
    depends_parser.add_argument('--useopttest', metavar='<pkg>', action='append', default=[],
            help="""Name of external package optionally used by tests of this project (case sensitive).""")
    
    # ----------------------------------------------------------------------------
    # command: create
    create_parser = subparsers.add_parser('create', parents=[shared_parser,depends_parser,template_parser],
            help="""Create a new project or template""")

    # --noalter
    create_parser.add_argument('--noalter', action='store_true', default=False,
            help="""Disable alteration of template files.""")

    # --new-template
    create_parser.add_argument('--new-template', action='store_true', default=False,
            help="""Create a new template for generating projects instead of a project. Implies --noalter.""")

    # --name/--description/--author
    create_parser.add_argument('--name', metavar='<name>', default=None, required=True,
            help="Name of new project.")

    create_parser.add_argument('--description', metavar='<text>', default=None,
            help="Brief project description.")

    create_parser.add_argument('--author', metavar='<author>', default='',
            help="Name of original author of the software.")

    # ----------------------------------------------------------------------------
    # command: update
    update_parser = subparsers.add_parser('update', parents=[shared_parser,depends_parser,template_parser],
            help="""Modify an existing project.""")

    # --original
    original_template_help="""Root directory of project template which the already existing project
was created from or last updated to. By default, the path of the original template
is extracted from the BasisProject.cmake file of the project. This path can be relative to
to the installation directory of the default templates. If this option is specified
on the command-line, paths can also be relative to the current working directory.
Absolute paths are always possible. If the specified previous template is not available,
an automatic upgrade of project files to a newer template is not feasible."""

    update_parser.add_argument('--original', metavar='<dir>', default=None,
            type=os.path.abspath, dest='original_template', help=original_template_help)

    # --force
    update_parser.add_argument('-f', '--force', action='store_true', default=False,
            help="""Enable removal of non-empty directories and modified project files.
By default, only empty directories and project files which have not
been edited since their creation are removed.""")

    # ----------------------------------------------------------------------------
    # command: upgrade
    upgrade_parser = subparsers.add_parser('upgrade', parents=[shared_parser,template_parser],
            help="""Upgrade an existing project to a newer template version.""")

    # --original
    upgrade_parser.add_argument('--original', metavar='<dir>', default=None,
            type=os.path.abspath, dest='original_template', help=original_template_help)

    # ----------------------------------------------------------------------------
    # command: help

    class PrintHelp(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            if   values[0] == 'create':  print(create_parser .format_help())
            elif values[0] == 'update':  print(update_parser .format_help())
            elif values[0] == 'upgrade': print(upgrade_parser.format_help())
            else:                        print(parser        .format_help())
            sys.exit(0)

    help_parser = subparsers.add_parser('help', help='Show command help.', add_help=False)
    help_parser.add_argument('command', nargs=1, action=PrintHelp, default='all', help='Show help of named command.')

    # ----------------------------------------------------------------------------
    # parse common options
    
    # @sa https://stackoverflow.com/questions/20094215/argparse-subparser-monolithic-help-output
    if hasattr(args, 'helpall') and args.helpall:
        # print main help
        parser.print_help()
        # retrieve subparsers from parser
        subparsers_actions = [
            action for action in parser._actions 
            if isinstance(action, argparse._SubParsersAction)]
        # there will probably only be one subparser_action,
        # but better save than sorry
        for subparsers_action in subparsers_actions:
            # get all subparsers and print help
            for choice, subparser in subparsers_action.choices.items():
                print("\n\nUsing the 'basisproject {}' command:".format(choice))
                print(subparser.format_help())
        sys.exit(1)
    if len(argv) == 0:
        parser.print_help()
        sys.exit(1)
    if len(argv_remaining) > 0:
        args = parser.parse_args(argv_remaining, args)
    if not hasattr(args, 'ops'):
        setattr(args, 'ops', {})

    # ------------------------------------------------------------------------
    # create new project or update existing one?

    # request to create new project
    if args.subparser_name == 'create':
        create       = True
        args.upgrade = False
        args.backup  = False
        # option --new-template implies --noalter
        if args.new_template: args.noalter = True
        # require also template _config.py when creating a new project template
        if args.new_template: config.required.insert(0, '_config.py')
        # create subdirectory in current working directory by default
        if not args.root:
            args.root = os.path.join(os.getcwd(), args.name)
        # ensure that root directory is empty
        if os.path.exists(args.root) and len(os.listdir(args.root)) != 0:
            sys.stderr.write("Directory " + args.root + " exists already and is not empty.\n")
            if args.new_template:
                sys.stderr.write("Please choose another template name or a different root directory using the --root option.\n")
            else:
                sys.stderr.write("Please choose another project name or a different root directory using the --root option.\n")
                sys.stderr.write('\n')
                sys.stderr.write("If you want to modify an existing project, please specify the root directory\n")
                sys.stderr.write("of the existing project using the --root option and remove the --name option.\n")
            sys.exit(1)
        # create default version subdirectory inside new template directory
        if args.new_template: args.root = os.path.join(args.root, '1.0')
        # set path of original template to current template
        args.original_template = args.template
        # warn if project description is ignored
        if args.new_template and args.description:
            sys.stderr.write("Project description ignored. Creating a new project template.\n")
        # verify that name is valid
        if not re.match(r'^[a-zA-Z0-9][-+_a-zA-Z0-9]+$', args.name):
            if args.new_template:
                sys.stderr.write("Invalid template name: " + args.name + "\n\n")
                sys.stderr.write("A template name may only consist of alphanumeric characters, `-`, `+`, and `_`!\n")
            else:
                sys.stderr.write("Invalid project name: " + args.name + "\n\n")
                sys.stderr.write("A project name may only consist of alphanumeric characters, `-`, `+`, and `_`!\n")
                sys.stderr.write("If you are attempting to modify an existing project, check if the\n")
                sys.stderr.write("project name has been correctly extracted from the BasisProject.cmake file.\n")
            sys.exit(1)
    # request to modify existing project
    else:
        create = False
        # whether to upgrade existing project files
        if args.subparser_name == 'upgrade': args.upgrade = True
        else:                                args.upgrade = False
        # use current working directory if root not specified
        if not args.root:
            args.root = os.getcwd()
        # remove trailing slashes from root
        if args.root[-1] == '/' or args.root[-1] == '\\':
            args.root = args.root[0:-1]
        # check existence of root directory
        if not os.path.isdir(args.root):
            sys.stderr.write("Project directory " + args.root + " does not exist!\n")
            sys.stderr.write("If you want to create a new project, please specify a project name.\n")
            sys.exit(1)
        # is project a BASIS project?
        if not os.path.isfile(os.path.join(args.root, 'BasisProject.cmake')):
            sys.stderr.write("Could not find a BasisProject.cmake file in " + args.root +
                    "! Are you sure this path is to a BASIS project?\n\n"
                    + "If you do not provide a project name, basisproject assumes you want to upgrade a previously created BASIS-project."
                    + "This means that it performs a 3-way diff as described in the documentation. If any of the template files"
                    + "have been edited, e.g., because of a newer template version with slight changes, these are merged with "
                    + "the project files.\n\n"
                    + "If you want to create a new project into an empty directory, you must specify the --name and --description options.\n\n"
                    + "See the documentation section on How To Create and Modify a Project for more details.")
            sys.exit(1)
        # notify user that --description option is invalid
        if hasattr(args, 'description') and args.description:
            sys.stderr.write("Cannot modify description of existing project. Please edit file BasisProject.cmake.\n")
            sys.stderr.write("Do not use option --description when attempting to modify an existing project.\n")
            sys.exit(1)
        # get project name
        if not hasattr(args, 'description') or not args.name:
            args.name = get_project_name(os.path.join(args.root, 'BasisProject.cmake'))
            if not args.name:
                sys.stderr.write("Failed to determine project name!\n")
                sys.exit(1)
        # get original template directory
        if args.original_template:
            args.original_template = template_abspath(args.original_template)
        else:
            args.original_template = get_original_template(args)
            if not args.original_template:
                sys.stderr.write("Failed to determine original template directory and version!\n")
                sys.exit(1)

    # print template and root path
    if args.verbose > 1:
        print("Project:  " + args.root)
        print("Template: " + args.template)
        print("Original: " + args.original_template)
        print
 
    # ------------------------------------------------------------------------
    # adjust template options
    args.ops = get_config_options(args.root, config, args, create)

    # ------------------------------------------------------------------------
    # do not update exiting project if previous conflicts are not resolved
    if not create:
        for root, dirs, files in os.walk(args.root):
            for filename in files:
                if (filename.endswith('.mine')
                        or filename.endswith('.template')
                        or filename.endswith('~')):
                    if args.cleanup:
                        file_path = os.path.join(root, filename)
                        try:
                            os.remove(file_path)
                            print("D %s" % file_path)
                        except Exception as e:
                            sys.stderr.write("E %s - failed to remove file" % file_path)
                            if args.verbose > 0: sys.stderr.write(': ' + text_type(e))
                            sys.stderr.write('\n')
                            ok = False
                    elif args.upgrade and not filename.endswith('~'):
                        sys.stderr.write(
"""Conflicts occured when updating the project files before.

Please resolve these conflicts first by editing the conflicted files, then remove
the *.mine and *.template files or run this program with the --cleanup option.
Once these conflicts have been resolved, try updating again.

Note that if you want to revert the previous udpate entirely, you should use
the revert functionality of the revision control system that you are hopefully
using to manage your project files. This should also revert the copies of the
template files in the .basis/ subdirectory.
""")
                        sys.exit(1)
        if args.cleanup and not ok:
            sys.stderr.write("\nFailed to cleanup backup files and temporary files\n")
            sys.exit(1)

    # ------------------------------------------------------------------------
    # create/modify project
    acc = AccumulatorForNumbersOfChangesAndErrors()

    try:
        # required project files
        for path in config.required:
            acc.call(add, path, args)
        # optional template files
        for opt in sorted(config.options.keys()):
            op = args.ops.get(opt, None)
            for path in config.options[opt].get('path', []):
                acc.call(addordel, op, path, args)
        # update template version
        if args.subparser_name == 'upgrade':
            acc.call(update_project_template, args)
    except Exception as e:
        sys.stderr.write("Failed to ")
        if create: sys.stderr.write("create")
        else:      sys.stderr.write("modify")
        sys.stderr.write(" project: " + text_type(e) + "\n\n\tPlease check for existing issues related to this error.\t\tIf you cannot find anything please file a report at:\n\thttps://github.com/cmake-basis/BASIS/issues/")
        ok = False
        raise e

    # ------------------------------------------------------------------------
    # done
    if ok:
        if create:
            if args.new_template:
                sys.stdout.write("\nCreated template\n")
            else:
                sys.stdout.write("\nCreated project\n")
        else:
            if acc.changes > 0:
                sys.stdout.write('\n' + text_type(acc.changes) + " file")
                if acc.changes > 1: sys.stdout.write('s')
                sys.stdout.write(" added (A), removed (D), or modified (G, C)\n")
            elif acc.errors == 0:
                if args.upgrade:
                    sys.stdout.write("Project is up to date\n")
                else:
                    sys.stdout.write("No project files added, removed, or modified\n")
        if acc.errors > 0:
            if acc.changes == 0: sys.stderr.write('\n')
            sys.stderr.write(text_type(acc.errors) + " error")
            if acc.errors > 1: sys.stderr.write('s')
            sys.stderr.write(" encountered\n")
        if acc.conflicts > 0:
            sys.stderr.write(text_type(acc.conflicts) + " conflicting change")
            if acc.conflicts > 1: sys.stderr.write('s')
            sys.stderr.write(" (C) encountered\n")
            sys.stderr.write(
"""
Resolve conflicts by editing the updated files manually, using the corresonding *.mine
and *.template files as reference. Once a conflict is resolved, remove these files.
""")
